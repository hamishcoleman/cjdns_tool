#!/usr/bin/env perl
use warnings;
use strict;
#
# The simplest tool was the raw rpc tool
#

# The default options - should be set from commandline or rc file eventually
my $option = {
    addr     => "127.0.0.1",
    port     => "11234",
    password => "NONE",
    trace    => 1,
};

package Stream::String;
use warnings;
use strict;
#
# In another example of yak shaving, I dont want to install libio-string-perl

sub new {
    my $class = shift;
    my $self = {};
    bless $self, $class;
    $self->{_pos} = 0;
    $self->{_string} = shift || die("empty strings are unsupported");
    return $self;
}

sub eof {
    my $self = shift;
    if ($self->{_pos} >= length($self->{_string})) {
        return 1;
    }
    return 0;
}

sub getc {
    my $self = shift;
    if ($self->eof()) {
        # accessing beyond the end of the string
        return undef;
    }
    return substr($self->{_string},$self->{_pos}++,1);
}

sub ungetc {
    my $self = shift;
    my $ch && die("cannot specify the ungetc char");
    if ($self->{_pos} == 0) {
        return undef;
    }
    $self->{_pos}--;
    return 1;
}

sub read {
    my $self = shift;
    my $count = shift;
    my $result = substr($self->{_string}, $self->{_pos}, $count);
    $self->{_pos} += $count;
    return $result;
}

1;

package Bencode_bork;
use warnings;
use strict;
#
# I did so well on the decoder, that when I discovered that I could not simply
# install the libbencode-perl without dragging 33Meg of stuff in, I thought
# "why not write an encoder too" ..
#
# Unfortunately, the bencoder used by cjdns thinks that zero prefixing the
# string length is a valid action, so I cannot simply use the debian
# libbdecode-perl package
#

sub _encode_value {
    my $value = shift;

    if (ref($value) eq 'HASH') {
        my @r;
        push @r,'d';
        # bencode specifies a sort order, so make sure we use it
        for my $key (sort(keys(%{$value}))) {
            push @r, _encode_value($key);
            push @r, _encode_value($value->{$key});
        }
        push @r,'e';
        return @r;
    }

    if (ref($value) eq 'ARRAY') {
        my @r;
        push @r,'l';
        for my $i (@{$value}) {
            push @r, _encode_value($i);
        }
        push @r,'e';
        return @r;
    }

    if (ref($value) eq 'SCALAR') {
        return _encode_value($$value);
    }

    if ($value =~ m/^-?[0-9]$/) {
        return 'i',$value,'e';
    }

    return length($value),':',$value;
}

sub encode {
    my $data = shift;
    return join('',_encode_value($data));
}

sub _get_type {
    my $sh = shift;
    return $sh->getc();
}

# FIXME - negative numbers
sub _get_int_raw {
    my $sh = shift;
    my $int = 0;
    my $ch = $sh->getc();
    die("syntax") if ($ch !~ m/[0-9]/); # at least one digit
    while (1) {
        $int += $ch;
        $ch = $sh->getc();
        if ($ch !~ m/[0-9]/) {
            $sh->ungetc();
            return $int;
        }
        $int *= 10;
    }
    ...
}

sub _get_int {
    my $sh = shift;
    my $int = _get_int_raw($sh);
    my $ch = $sh->getc();
    die("syntax") if ($ch ne 'e');
    return $int;
}

sub _get_string {
    my $sh = shift;
    my $count = _get_int_raw($sh);
    my $ch = $sh->getc();
    die("syntax") if ($ch ne ':');
    return $sh->read($count);
}

sub _get_array {
    my $sh = shift;
    my @result;
    while (1) {
        my $type = _get_type($sh);
        last if ($type eq 'e');
        die("syntax") if ($type !~ m/[-0-9dli]/);
        $sh->ungetc();

        my $value = _get_value($sh);
        push @result, $value;
    }
    return @result;
}

sub _get_value {
    my $sh = shift;
    my $output;
    my $type = _get_type($sh);

    if ($type eq 'd') {
        return {_get_array($sh)};
    }
    if ($type eq 'l') {
        return [_get_array($sh)];
    }
    if ($type eq 'i') {
        return _get_int($sh);
    }
    if ($type =~ m/[0-9]/) {
        # a string
        $sh->ungetc();
        return _get_string($sh);
    }
    die("syntax");
}

sub decode {
    my $input_string = shift;
    my $sh = Stream::String->new($input_string);
    my $result = _get_value($sh);
    if (!$sh->eof()) {
        my $garbage = $sh->read();
        warn("trailing garbage: ",$garbage);
    }
    return $result;
}

1;

package RPC;
use warnings;
use strict;
#
# Wrap the communications
#

use Digest::SHA qw(sha256_hex);

sub new {
    my $class = shift;
    my $addr = shift || die("need address");
    my $port = shift || die("need port");
    my $password = shift || die("need password");

    my $self = {};
    bless $self, $class;

    $self->{_fh} = IO::Socket::INET->new(
        Proto    => "udp",
        PeerAddr => $addr,
        PeerPort => $port,
    ) or die "Cannot connect: $!\n";
    $self->{_txcount} = 0;
    $self->{_password} = $password;
    return $self;
}

sub trace {
    my $self = shift;
    $self->{trace} = shift;
    return $self->{trace};
}

sub _trace {
    my $self = shift;
    my $direction = shift;
    my $packet = shift;

    if ($self->{trace}) {
        print($direction," ",$packet,"\n");
    }
}

sub _txid {
    my $self = shift;
    return $$.'-'.$self->{_txcount}++;
}

sub _build_query_unauth {
    my $self = shift;
    my $q = shift;

    my $packet = {
        q => $q,
        txid => $self->_txid(),
    };

    if (scalar(@_)) {
        $packet->{args} = { @_ };
    }

    return $packet;
}

sub _build_query_auth {
    my $self = shift;
    my $aq = shift;

    die("no auth") if (!defined($self->{_hash}));
    die("no cookie") if (!defined($self->{_cookie}));

    my $cookie = sprintf("%i",$self->{_cookie});
    my $packet = {
        q => 'auth',
        aq => $aq,
        txid => $self->_txid(),
        cookie => \$cookie,
        hash => $self->{_hash},
    };

    if (scalar(@_)) {
        $packet->{args} = { @_ };
    }

    my $buf = Bencode_bork::encode($packet);
    $packet->{hash} = sha256_hex($buf);
    return $packet;
}

sub _sync_call {
    my $self = shift;
    my $packet = shift;
    my $txid = $packet->{txid};

    my $buf = Bencode_bork::encode($packet);
    $self->_trace(">",$buf);
    $self->{_fh}->syswrite($buf);

    $buf = $self->_read();
    if (defined($txid) && $buf->{txid} ne $txid) {
        die("txid mismatch");
    }
    return $buf;
}

sub _read {
    my $self = shift;

    my $buf;
    $self->{_fh}->sysread($buf,4096);
    $self->_trace("<",$buf);
    return Bencode_bork::decode($buf);
}

sub ping {
    my $self = shift;

    my $packet = $self->_build_query_unauth('ping');
    return $self->_sync_call($packet);
}

sub ping_auth {
    my $self = shift;

    my $packet = $self->_build_query_auth('ping');
    return $self->_sync_call($packet);
}

sub Admin_availableFunctions {
    my $self = shift;
    my $page = 0;

    my $more = 1;
    while ($more) {
        my $packet = $self->_build_query_unauth(
            'Admin_availableFunctions',
            page=>$page
        );
        my $buf = $self->_sync_call($packet);

        for my $fn (keys(%{$buf->{availableFunctions}})) {
            $self->{_fn}{$fn} = $buf->{availableFunctions}{$fn};
        }
        $more = $buf->{more};
        $page++;
    }
    return $self->{_fn};
}

sub cookie {
    my $self = shift;
    my $packet = $self->_build_query_unauth('cookie');
    my $buf = $self->_sync_call($packet);
    $self->{_cookie} = $buf->{cookie};
    $self->{_hash} = sha256_hex($self->{_password}.$self->{_cookie});
    return $buf;
}

1;

package main;
use warnings;
use strict;

use Data::Dumper;
$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Quotekeys = 0;

use IO::Socket;

sub main() {
    my $rpc = RPC->new(
        $option->{addr},
        $option->{port},
        $option->{password},
    ) or die "cannot start rpc";
    $rpc->trace($option->{trace});

    print(Dumper($rpc->ping()));
    print(Dumper($rpc->cookie()));
    print(Dumper($rpc->ping_auth()));

    #print(Dumper($rpc->Admin_availableFunctions()));

    my $packet;
    $packet = $rpc->_build_query_auth('ETHInterface_listDevices');
    print(Dumper($rpc->_sync_call($packet)));
}
main();
